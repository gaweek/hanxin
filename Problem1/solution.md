## 复杂度分析

### 直接算法复杂度分析

#### 时间复杂度：O(n²)
- **证明**：
  1. 外层循环执行n次（i从0到n-1）
  2. 内层循环执行n次（j从0到n-1）
  3. 每次内层循环包含：
     - 1次索引计算（k = n-1 + i - j）
     - 1次数组访问（a[k]和v[j]）
     - 1次乘法运算
     - 1次加法运算
  4. 总操作次数：n × n × 4 = 4n²次基本操作
  5. 根据大O记号定义，时间复杂度为O(n²)

#### 空间复杂度：O(1)额外空间
- **证明**：
  - 除了输入数组a（长度2n-1）、输入向量v（长度n）和输出向量y（长度n）
  - 算法只使用了常数个临时变量（i, j, k）
  - 因此额外空间复杂度为O(1)

### FFT优化算法复杂度分析

#### 时间复杂度：O(n log n)
- **证明**：
  1. 数组扩展：O(n)时间
  2. FFT计算：O(m log m)时间，其中m = O(n)
  3. 频域相乘：O(m) = O(n)时间
  4. 逆FFT计算：O(m log m) = O(n log n)时间
  5. 结果提取：O(n)时间
  6. 由于FFT计算是主导项，总时间复杂度为O(n log n)

#### 空间复杂度：O(n)
- **证明**：
  - 需要O(m) = O(n)空间存储扩展数组x_ext和v_ext
  - 需要O(m) = O(n)空间存储FFT的中间结果
  - 因此总空间复杂度为O(n)

## 算法正确性证明

### 直接算法正确性
设矩阵$A$为反向对称矩阵，根据定义：
$$A_{i,j} = a_{n-1 + i - j}$$

矩阵向量乘积的第i个分量为：
$$y_i = \sum_{j=0}^{n-1} A_{i,j} \cdot v_j = \sum_{j=0}^{n-1} a_{n-1 + i - j} \cdot v_j$$

算法第4-5行精确计算了这个表达式，因此算法正确。

### FFT优化算法正确性
托普利茨矩阵与向量的乘法可以表示为卷积运算：
$$y_i = \sum_{j=0}^{n-1} a_{n-1 + i - j} \cdot v_j = (a * v)_{n-1+i}$$

根据卷积定理，时域卷积等价于频域相乘：
$$\mathcal{F}\{a * v\} = \mathcal{F}\{a\} \cdot \mathcal{F}\{v\}$$

因此通过FFT方法可以正确计算结果，算法正确性得证。

## 性能比较

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| 直接算法 | O(n²) | O(1) | n较小的情况（n < 1000） |
| FFT算法 | O(n log n) | O(n) | n较大的情况（n ≥ 1000） |

## 实现注意事项

1. **索引处理**：注意编程语言中数组索引通常从0开始
2. **边界检查**：确保索引k = n-1 + i - j在[0, 2n-2]范围内
3. **数值稳定性**：FFT算法可能存在浮点数精度问题
4. **内存访问**：直接算法具有较好的局部性，适合缓存优化

---
*最后更新：2025年11月18日*  
*作者：gaweek*
